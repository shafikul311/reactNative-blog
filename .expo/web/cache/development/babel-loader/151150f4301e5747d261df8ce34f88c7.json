{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _utils = require(\"./utils\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction getSharedElements(sceneData, otherSceneData, showing) {\n  var sharedElements = sceneData.Component.sharedElements;\n  if (!sharedElements) return null;\n  return (0, _utils.normalizeSharedElementsConfig)(sharedElements(sceneData.route, otherSceneData.route, showing));\n}\n\nvar NO_SHARED_ELEMENTS = [];\n\nvar SharedElementRendererData = function () {\n  function SharedElementRendererData() {\n    (0, _classCallCheck2.default)(this, SharedElementRendererData);\n    (0, _defineProperty2.default)(this, \"scenes\", []);\n    (0, _defineProperty2.default)(this, \"updateSubscribers\", new Set());\n    (0, _defineProperty2.default)(this, \"sharedElements\", null);\n    (0, _defineProperty2.default)(this, \"isShowing\", true);\n    (0, _defineProperty2.default)(this, \"route\", null);\n    (0, _defineProperty2.default)(this, \"prevRoute\", null);\n    (0, _defineProperty2.default)(this, \"routeAnimValue\", void 0);\n    (0, _defineProperty2.default)(this, \"scene\", null);\n    (0, _defineProperty2.default)(this, \"prevScene\", null);\n    (0, _defineProperty2.default)(this, \"sceneAnimValue\", void 0);\n    (0, _defineProperty2.default)(this, \"isTransitionStarted\", false);\n    (0, _defineProperty2.default)(this, \"isTransitionClosing\", false);\n    (0, _defineProperty2.default)(this, \"transitionNavigatorId\", '');\n    (0, _defineProperty2.default)(this, \"transitionNestingDepth\", -1);\n    (0, _defineProperty2.default)(this, \"isVerbose\", false);\n  }\n\n  (0, _createClass2.default)(SharedElementRendererData, [{\n    key: \"startTransition\",\n    value: function startTransition(closing, navigatorId, nestingDepth) {\n      if (this.isVerbose) console.debug(\"startTransition[\".concat(navigatorId, \"], closing: \").concat(closing, \", nestingDepth: \").concat(nestingDepth));\n\n      if (!this.isTransitionStarted || this.route) {\n        this.prevRoute = this.route;\n        this.route = null;\n        this.routeAnimValue = null;\n\n        if (this.isTransitionStarted) {\n          var scene = this.getScene(this.prevRoute);\n\n          if (scene) {\n            this.routeAnimValue = scene.getAnimValue(true);\n            if (this.isVerbose) console.debug(\"startTransition[\".concat(navigatorId, \"] using Animated.Value from \\\"\").concat(scene.name, \"\\\", animValue: \").concat(this.routeAnimValue));\n          }\n        }\n\n        this.isTransitionStarted = true;\n        this.isTransitionClosing = closing;\n        this.transitionNavigatorId = navigatorId;\n        this.transitionNestingDepth = nestingDepth;\n      } else {\n        if (nestingDepth < this.transitionNestingDepth) {\n          this.transitionNavigatorId = navigatorId;\n          this.transitionNestingDepth = nestingDepth;\n        }\n      }\n    }\n  }, {\n    key: \"endTransition\",\n    value: function endTransition(closing, navigatorId, nestingDepth) {\n      if (this.isVerbose) console.debug(\"endTransition[\".concat(navigatorId, \"], closing: \").concat(closing, \", nestingDepth: \").concat(nestingDepth));\n\n      if (!this.isTransitionStarted || this.transitionNavigatorId !== navigatorId) {\n        return;\n      }\n\n      this.isTransitionStarted = false;\n\n      if (this.prevRoute != null) {\n        this.prevRoute = null;\n        this.routeAnimValue = null;\n        this.updateSceneListeners();\n        this.updateSharedElements();\n      }\n    }\n  }, {\n    key: \"updateSceneState\",\n    value: function updateSceneState(sceneData, route, sceneEvent) {\n      switch (sceneEvent) {\n        case 'willFocus':\n          return this.willFocusScene(sceneData, route);\n\n        case 'didFocus':\n          return this.didFocusScene(sceneData, route);\n\n        case 'willBlur':\n          return this.willBlurScene(sceneData, route);\n      }\n    }\n  }, {\n    key: \"willFocusScene\",\n    value: function willFocusScene(sceneData, route) {\n      if (this.isVerbose) console.debug(\"willFocusScene[\".concat(sceneData.navigatorId, \"], name: \\\"\").concat(sceneData.name, \"\\\", depth: \").concat(sceneData.nestingDepth));\n      this.registerScene(sceneData, route);\n      if (!this.isTransitionStarted) return;\n\n      if (!this.isTransitionClosing && this.prevRoute && sceneData.navigatorId === this.transitionNavigatorId && !this.routeAnimValue) {\n        this.routeAnimValue = sceneData.getAnimValue(this.isTransitionClosing);\n        if (this.isVerbose) console.debug(\"willFocusScene[\".concat(sceneData.navigatorId, \"] using Animated.Value from \\\"\").concat(sceneData.name, \"\\\", animValue: \").concat(this.routeAnimValue));\n      }\n\n      if (!this.route) {\n        this.route = route;\n      } else {\n        var routeScene = this.getScene(this.route);\n\n        if (routeScene && routeScene.nestingDepth <= sceneData.nestingDepth) {\n          this.route = route;\n        }\n      }\n\n      if (this.prevRoute && this.route && this.routeAnimValue) {\n        this.updateSceneListeners();\n        this.updateSharedElements();\n      }\n    }\n  }, {\n    key: \"didFocusScene\",\n    value: function didFocusScene(sceneData, route) {\n      if (this.isVerbose) console.debug(\"didFocusScene[\".concat(sceneData.navigatorId, \"], name: \\\"\").concat(sceneData.name, \"\\\", depth: \").concat(sceneData.nestingDepth));\n\n      if (!this.route || this.prevRoute) {\n        this.route = route;\n      } else {\n        var routeScene = this.getScene(this.route);\n\n        if (routeScene && routeScene.nestingDepth <= sceneData.nestingDepth) {\n          this.route = route;\n        }\n      }\n\n      this.prevRoute = null;\n      this.registerScene(sceneData, route);\n    }\n  }, {\n    key: \"willBlurScene\",\n    value: function willBlurScene(sceneData, route) {\n      if (this.isVerbose) console.debug(\"willBlurScene[\".concat(sceneData.navigatorId, \"], name: \\\"\").concat(sceneData.name, \"\\\", depth: \").concat(sceneData.nestingDepth));\n      if (!this.isTransitionStarted) return;\n\n      if (this.isTransitionClosing && sceneData.navigatorId === this.transitionNavigatorId && !this.routeAnimValue) {\n        this.routeAnimValue = sceneData.getAnimValue(this.isTransitionClosing);\n        if (this.isVerbose) console.debug(\"willBlurScene[\".concat(sceneData.navigatorId, \"] using Animated.Value from \\\"\").concat(sceneData.name, \"\\\", animValue: \").concat(this.routeAnimValue));\n      }\n\n      if (this.prevRoute && this.route && this.routeAnimValue) {\n        this.updateSceneListeners();\n        this.updateSharedElements();\n      }\n    }\n  }, {\n    key: \"registerScene\",\n    value: function registerScene(sceneData, route) {\n      this.scenes.push({\n        scene: sceneData,\n        route: route,\n        subscription: null\n      });\n\n      if (this.scenes.length > 10) {\n        var subscription = this.scenes[0].subscription;\n        this.scenes.splice(0, 1);\n        if (subscription) subscription();\n      }\n\n      this.updateSceneListeners();\n    }\n  }, {\n    key: \"updateSceneListeners\",\n    value: function updateSceneListeners() {\n      var _this = this;\n\n      this.scenes.forEach(function (sceneRoute) {\n        var scene = sceneRoute.scene,\n            route = sceneRoute.route,\n            subscription = sceneRoute.subscription;\n        var isActive = _this.route && _this.route.key === route.key || _this.prevRoute && _this.prevRoute.key === route.key;\n\n        if (isActive && !subscription) {\n          sceneRoute.subscription = scene.addUpdateListener(function () {\n            _this.emitUpdateEvent();\n          });\n        } else if (!isActive && subscription) {\n          sceneRoute.subscription = null;\n          subscription();\n        }\n      });\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(route) {\n      var sceneRoute = route ? this.scenes.find(function (sc) {\n        return sc.route.key === route.key;\n      }) : undefined;\n      return sceneRoute ? sceneRoute.scene : null;\n    }\n  }, {\n    key: \"updateSharedElements\",\n    value: function updateSharedElements() {\n      var route = this.route,\n          prevRoute = this.prevRoute,\n          routeAnimValue = this.routeAnimValue;\n      var scene = this.getScene(route);\n      var prevScene = this.getScene(prevRoute);\n      var sceneAnimValue = routeAnimValue;\n      if (scene === this.scene && prevScene === this.prevScene && sceneAnimValue === this.sceneAnimValue) return;\n      this.scene = scene;\n      this.prevScene = prevScene;\n      this.sceneAnimValue = sceneAnimValue;\n      var sharedElements = null;\n      var isShowing = true;\n\n      if (sceneAnimValue && scene && prevScene) {\n        sharedElements = getSharedElements(scene, prevScene, true);\n\n        if (!sharedElements) {\n          isShowing = false;\n          sharedElements = getSharedElements(prevScene, scene, false);\n        }\n      }\n\n      if (this.sharedElements !== sharedElements) {\n        if (this.isVerbose) console.debug(\"Transitioning from \\\"\".concat(prevScene === null || prevScene === void 0 ? void 0 : prevScene.name, \"\\\" to \\\"\").concat(scene === null || scene === void 0 ? void 0 : scene.name, \"\\\", elements: \").concat(JSON.stringify(sharedElements)));\n        this.sharedElements = sharedElements;\n        this.isShowing = isShowing;\n        this.emitUpdateEvent();\n      }\n    }\n  }, {\n    key: \"addUpdateListener\",\n    value: function addUpdateListener(handler) {\n      var _this2 = this;\n\n      this.updateSubscribers.add(handler);\n      return function () {\n        return _this2.updateSubscribers.delete(handler);\n      };\n    }\n  }, {\n    key: \"emitUpdateEvent\",\n    value: function emitUpdateEvent() {\n      this.updateSubscribers.forEach(function (handler) {\n        return handler();\n      });\n    }\n  }, {\n    key: \"getTransitions\",\n    value: function getTransitions() {\n      var sharedElements = this.sharedElements,\n          prevScene = this.prevScene,\n          scene = this.scene,\n          isShowing = this.isShowing,\n          sceneAnimValue = this.sceneAnimValue,\n          route = this.route;\n      if (!sharedElements || !scene || !prevScene || !route) return NO_SHARED_ELEMENTS;\n      return sharedElements.map(function (_ref) {\n        var id = _ref.id,\n            otherId = _ref.otherId,\n            other = (0, _objectWithoutProperties2.default)(_ref, [\"id\", \"otherId\"]);\n        var startId = isShowing ? otherId || id : id;\n        var endId = isShowing ? id : otherId || id;\n        return _objectSpread({\n          key: route.key,\n          position: sceneAnimValue,\n          start: {\n            ancestor: (prevScene ? prevScene.getAncestor() : undefined) || null,\n            node: (prevScene ? prevScene.getNode(startId) : undefined) || null\n          },\n          end: {\n            ancestor: (scene ? scene.getAncestor() : undefined) || null,\n            node: (scene ? scene.getNode(endId) : undefined) || null\n          }\n        }, other);\n      });\n    }\n  }, {\n    key: \"nestingDepth\",\n    get: function get() {\n      return 0;\n    }\n  }]);\n  return SharedElementRendererData;\n}();\n\nexports.default = SharedElementRendererData;","map":{"version":3,"sources":["SharedElementRendererData.ts"],"names":["sharedElements","sceneData","otherSceneData","NO_SHARED_ELEMENTS","SharedElementRendererData","closing","navigatorId","nestingDepth","console","scene","route","sceneEvent","routeScene","subscription","sceneRoute","isActive","sc","prevRoute","routeAnimValue","prevScene","sceneAnimValue","isShowing","getSharedElements","JSON","handler","id","otherId","other","startId","endId","key","position","start","ancestor","node","end"],"mappings":"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","sourcesContent":["import SharedElementSceneData, {\n  SharedElementSceneEventType,\n} from './SharedElementSceneData';\nimport {\n  SharedElementEventSubscription,\n  SharedElementsStrictConfig,\n  SharedElementTransitionProps,\n  SharedElementRoute,\n} from './types';\nimport { normalizeSharedElementsConfig } from './utils';\nimport { Animated } from 'react-native';\n\nexport type SharedElementRendererUpdateHandler = () => any;\n\nexport interface ISharedElementRendererData {\n  startTransition(\n    closing: boolean,\n    navigatorId: string,\n    nestingDepth: number\n  ): void;\n  endTransition(\n    closing: boolean,\n    navigatorId: string,\n    nestingDepth: number\n  ): void;\n  updateSceneState(\n    sceneData: SharedElementSceneData,\n    route: SharedElementRoute,\n    sceneEvent: SharedElementSceneEventType\n  ): void;\n  readonly nestingDepth: number;\n}\n\nfunction getSharedElements(\n  sceneData: SharedElementSceneData,\n  otherSceneData: SharedElementSceneData,\n  showing: boolean\n): SharedElementsStrictConfig | null {\n  const { sharedElements } = sceneData.Component;\n  if (!sharedElements) return null;\n  return normalizeSharedElementsConfig(\n    sharedElements(sceneData.route, otherSceneData.route, showing)\n  );\n}\n\nconst NO_SHARED_ELEMENTS: any[] = [];\n\ntype SceneRoute = {\n  scene: SharedElementSceneData;\n  route: SharedElementRoute;\n  subscription: SharedElementEventSubscription | null;\n};\n\n/**\n * TODO\n *\n * - [X] Start animation on `startTransition`\n * - [X] Use animValue from started navigator\n * - [X] Use route from deepest nested scene\n * - [X] Support nesting\n * - [ ] Not all lifecycle events not emitted by stack when using gestures (close modal)\n */\n\nexport default class SharedElementRendererData\n  implements ISharedElementRendererData {\n  private scenes: SceneRoute[] = [];\n  private updateSubscribers = new Set<SharedElementRendererUpdateHandler>();\n  private sharedElements: SharedElementsStrictConfig | null = null;\n  private isShowing: boolean = true;\n\n  private route: SharedElementRoute | null = null;\n  private prevRoute: SharedElementRoute | null = null;\n  private routeAnimValue?: Animated.AnimatedInterpolation | null;\n\n  private scene: SharedElementSceneData | null = null;\n  private prevScene: SharedElementSceneData | null = null;\n  private sceneAnimValue?: Animated.AnimatedInterpolation | null;\n\n  private isTransitionStarted: boolean = false;\n  private isTransitionClosing: boolean = false;\n  private transitionNavigatorId: string = '';\n  private transitionNestingDepth: number = -1;\n\n  private isVerbose: boolean = false;\n\n  startTransition(closing: boolean, navigatorId: string, nestingDepth: number) {\n    if (this.isVerbose)\n      console.debug(\n        `startTransition[${navigatorId}], closing: ${closing}, nestingDepth: ${nestingDepth}`\n      );\n\n    if (!this.isTransitionStarted || this.route) {\n      this.prevRoute = this.route;\n      this.route = null;\n      this.routeAnimValue = null;\n\n      // When a transition wasn't completely fully, but a new transition\n      // has already started, then the `willBlur` event is not called.\n      // For this particular case, we capture the animation-value of the\n      // last (previous) scene that is now being hidden.\n      if (this.isTransitionStarted) {\n        const scene = this.getScene(this.prevRoute);\n        if (scene) {\n          this.routeAnimValue = scene.getAnimValue(true);\n          if (this.isVerbose)\n            console.debug(\n              `startTransition[${navigatorId}] using Animated.Value from \"${scene.name}\", animValue: ${this.routeAnimValue}`\n            );\n        }\n      }\n\n      this.isTransitionStarted = true;\n      this.isTransitionClosing = closing;\n      this.transitionNavigatorId = navigatorId;\n      this.transitionNestingDepth = nestingDepth;\n    } else {\n      // When navigators are nested, `startTransition` may be called multiple\n      // times. In such as case, we want to use the most shallow navigator,\n      // as that is the one doing the transition.\n      if (nestingDepth < this.transitionNestingDepth) {\n        this.transitionNavigatorId = navigatorId;\n        this.transitionNestingDepth = nestingDepth;\n      }\n    }\n  }\n\n  endTransition(closing: boolean, navigatorId: string, nestingDepth: number) {\n    if (this.isVerbose)\n      console.debug(\n        `endTransition[${navigatorId}], closing: ${closing}, nestingDepth: ${nestingDepth}`\n      );\n\n    if (\n      !this.isTransitionStarted ||\n      this.transitionNavigatorId !== navigatorId\n    ) {\n      return;\n    }\n\n    this.isTransitionStarted = false;\n\n    if (this.prevRoute != null) {\n      this.prevRoute = null;\n      this.routeAnimValue = null;\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }\n\n  updateSceneState(\n    sceneData: SharedElementSceneData,\n    route: SharedElementRoute,\n    sceneEvent: SharedElementSceneEventType\n  ): void {\n    switch (sceneEvent) {\n      case 'willFocus':\n        return this.willFocusScene(sceneData, route);\n      case 'didFocus':\n        return this.didFocusScene(sceneData, route);\n      case 'willBlur':\n        return this.willBlurScene(sceneData, route);\n    }\n  }\n\n  willFocusScene(\n    sceneData: SharedElementSceneData,\n    route: SharedElementRoute\n  ): void {\n    if (this.isVerbose)\n      console.debug(\n        `willFocusScene[${sceneData.navigatorId}], name: \"${sceneData.name}\", depth: ${sceneData.nestingDepth}`\n      );\n    this.registerScene(sceneData, route);\n\n    // Wait for a transition start, before starting any animations\n    if (!this.isTransitionStarted) return;\n\n    // Use the animation value from the navigator that\n    // started the transition\n    if (\n      !this.isTransitionClosing &&\n      this.prevRoute &&\n      sceneData.navigatorId === this.transitionNavigatorId &&\n      !this.routeAnimValue\n    ) {\n      this.routeAnimValue = sceneData.getAnimValue(this.isTransitionClosing);\n      if (this.isVerbose)\n        console.debug(\n          `willFocusScene[${sceneData.navigatorId}] using Animated.Value from \"${sceneData.name}\", animValue: ${this.routeAnimValue}`\n        );\n    }\n\n    // In case of nested navigators, multiple scenes will become\n    // activated. Make sure to use the scene that is nested most deeply,\n    // as this will be the one visible to the user\n    if (!this.route) {\n      this.route = route;\n    } else {\n      const routeScene = this.getScene(this.route);\n      if (routeScene && routeScene.nestingDepth <= sceneData.nestingDepth) {\n        this.route = route;\n      }\n    }\n\n    // Update transition\n    if (this.prevRoute && this.route && this.routeAnimValue) {\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }\n\n  didFocusScene(\n    sceneData: SharedElementSceneData,\n    route: SharedElementRoute\n  ): void {\n    if (this.isVerbose)\n      console.debug(\n        `didFocusScene[${sceneData.navigatorId}], name: \"${sceneData.name}\", depth: ${sceneData.nestingDepth}`\n      );\n\n    if (!this.route || this.prevRoute) {\n      this.route = route;\n    } else {\n      const routeScene = this.getScene(this.route);\n      if (routeScene && routeScene.nestingDepth <= sceneData.nestingDepth) {\n        this.route = route;\n      }\n    }\n    this.prevRoute = null;\n    this.registerScene(sceneData, route);\n  }\n\n  willBlurScene(\n    sceneData: SharedElementSceneData,\n    // @ts-ignore\n    route: SharedElementRoute // eslint-disable-line @typescript-eslint/no-unused-vars\n  ): void {\n    if (this.isVerbose)\n      console.debug(\n        `willBlurScene[${sceneData.navigatorId}], name: \"${sceneData.name}\", depth: ${sceneData.nestingDepth}`\n      );\n\n    // Wait for a transition start, before starting any animations\n    if (!this.isTransitionStarted) return;\n\n    // Use the animation value from the navigator that\n    // started the transition\n    if (\n      this.isTransitionClosing &&\n      sceneData.navigatorId === this.transitionNavigatorId &&\n      !this.routeAnimValue\n    ) {\n      this.routeAnimValue = sceneData.getAnimValue(this.isTransitionClosing);\n      if (this.isVerbose)\n        console.debug(\n          `willBlurScene[${sceneData.navigatorId}] using Animated.Value from \"${sceneData.name}\", animValue: ${this.routeAnimValue}`\n        );\n    }\n\n    // Update transition\n    if (this.prevRoute && this.route && this.routeAnimValue) {\n      this.updateSceneListeners();\n      this.updateSharedElements();\n    }\n  }\n\n  private registerScene(\n    sceneData: SharedElementSceneData,\n    route: SharedElementRoute\n  ) {\n    this.scenes.push({\n      scene: sceneData,\n      route,\n      subscription: null,\n    });\n    if (this.scenes.length > 10) {\n      const { subscription } = this.scenes[0];\n      this.scenes.splice(0, 1);\n      if (subscription) subscription();\n    }\n    this.updateSceneListeners();\n    //this.updateSharedElements();\n  }\n\n  private updateSceneListeners() {\n    this.scenes.forEach(sceneRoute => {\n      const { scene, route, subscription } = sceneRoute;\n      const isActive =\n        (this.route && this.route.key === route.key) ||\n        (this.prevRoute && this.prevRoute.key === route.key);\n      if (isActive && !subscription) {\n        sceneRoute.subscription = scene.addUpdateListener(() => {\n          // TODO optimize\n          this.emitUpdateEvent();\n        });\n      } else if (!isActive && subscription) {\n        sceneRoute.subscription = null;\n        subscription();\n      }\n    });\n  }\n\n  private getScene(\n    route: SharedElementRoute | null\n  ): SharedElementSceneData | null {\n    const sceneRoute = route\n      ? this.scenes.find(sc => sc.route.key === route.key)\n      : undefined;\n    return sceneRoute ? sceneRoute.scene : null;\n  }\n\n  private updateSharedElements() {\n    const { route, prevRoute, routeAnimValue } = this;\n    const scene = this.getScene(route);\n    const prevScene = this.getScene(prevRoute);\n    const sceneAnimValue = routeAnimValue;\n\n    // Update current scene & previous scene\n    if (\n      scene === this.scene &&\n      prevScene === this.prevScene &&\n      sceneAnimValue === this.sceneAnimValue\n    )\n      return;\n    this.scene = scene;\n    this.prevScene = prevScene;\n    this.sceneAnimValue = sceneAnimValue;\n\n    // Update shared elements\n    let sharedElements: SharedElementsStrictConfig | null = null;\n    let isShowing = true;\n    if (sceneAnimValue && scene && prevScene) {\n      sharedElements = getSharedElements(scene, prevScene, true);\n      if (!sharedElements) {\n        isShowing = false;\n        sharedElements = getSharedElements(prevScene, scene, false);\n      }\n    }\n    if (this.sharedElements !== sharedElements) {\n      if (this.isVerbose)\n        console.debug(\n          `Transitioning from \"${prevScene?.name}\" to \"${\n            scene?.name\n          }\", elements: ${JSON.stringify(sharedElements)}`\n        );\n      this.sharedElements = sharedElements;\n      this.isShowing = isShowing;\n      /*console.log(\n        'updateSharedElements: ',\n        sharedElements,\n        ' ,isShowing: ',\n        isShowing,\n        ', animValue: ',\n        animValue\n      );*/\n      this.emitUpdateEvent();\n    }\n  }\n\n  addUpdateListener(\n    handler: SharedElementRendererUpdateHandler\n  ): SharedElementEventSubscription {\n    this.updateSubscribers.add(handler);\n    return () => this.updateSubscribers.delete(handler);\n  }\n\n  private emitUpdateEvent(): void {\n    this.updateSubscribers.forEach(handler => handler());\n  }\n\n  getTransitions(): SharedElementTransitionProps[] {\n    const {\n      sharedElements,\n      prevScene,\n      scene,\n      isShowing,\n      sceneAnimValue,\n      route,\n    } = this;\n\n    if (!sharedElements || !scene || !prevScene || !route)\n      return NO_SHARED_ELEMENTS;\n    return sharedElements.map(({ id, otherId, ...other }) => {\n      const startId = isShowing ? otherId || id : id;\n      const endId = isShowing ? id : otherId || id;\n      return {\n        key: route.key,\n        position: sceneAnimValue,\n        start: {\n          ancestor: (prevScene ? prevScene.getAncestor() : undefined) || null,\n          node: (prevScene ? prevScene.getNode(startId) : undefined) || null,\n        },\n        end: {\n          ancestor: (scene ? scene.getAncestor() : undefined) || null,\n          node: (scene ? scene.getNode(endId) : undefined) || null,\n        },\n        ...other,\n      };\n    });\n  }\n\n  get nestingDepth(): number {\n    return 0;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}