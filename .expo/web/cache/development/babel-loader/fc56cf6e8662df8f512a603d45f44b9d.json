{"ast":null,"code":"export function parseColor(color) {\n  if (Array.isArray(color)) return color;\n  var cache;\n  var p = parseInt;\n  color = color.replace(/\\s/g, \"\");\n  if (cache = /#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color)) return [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), 1];else if (cache = /#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color)) return [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17, 1];else if (cache = /rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color)) return [+cache[1], +cache[2], +cache[3], +cache[4]];else if (cache = /rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color)) return [+cache[1], +cache[2], +cache[3], 1];else throw new Error(color + \" is not supported by parseColor\");\n}\nexport function formatColor(color) {\n  return \"rgba(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \",\" + color[3] + \")\";\n}\nexport function interpolateColor(color1, color2, position) {\n  return color1.map(function (c, i) {\n    return c + (color2[i] - c) * position;\n  });\n}","map":{"version":3,"sources":["../../src/web/Color.web.ts"],"names":[],"mappings":"AAEA,OAAM,SAAU,UAAV,CAAqB,KAArB,EAA0C;AAC9C,MAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B,OAAO,KAAP;AAC1B,MAAI,KAAJ;AACA,MAAM,CAAC,GAAG,QAAV;AACA,EAAA,KAAK,GAAG,KAAK,CAAC,OAAN,CAAc,KAAd,EAAqB,EAArB,CAAR;AAGA,MAAK,KAAK,GAAG,iDAAiD,IAAjD,CAAsD,KAAtD,CAAb,EACE,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAF,EAAkB,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAnB,EAAmC,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAApC,EAAoD,CAApD,CAAP,CADF,KAGK,IAAK,KAAK,GAAG,wCAAwC,IAAxC,CAA6C,KAA7C,CAAb,EACH,OAAO,CACL,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAD,GAAkB,EADb,EAEL,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAD,GAAkB,EAFb,EAGL,CAAC,CAAC,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAD,GAAkB,EAHb,EAIL,CAJK,CAAP,CADG,KASA,IACF,KAAK,GAAG,sDAAsD,IAAtD,CAA2D,KAA3D,CADN,EAGH,OAAO,CAAC,CAAC,KAAK,CAAC,CAAD,CAAP,EAAY,CAAC,KAAK,CAAC,CAAD,CAAlB,EAAuB,CAAC,KAAK,CAAC,CAAD,CAA7B,EAAkC,CAAC,KAAK,CAAC,CAAD,CAAxC,CAAP,CAHG,KAMA,IAAK,KAAK,GAAG,iCAAiC,IAAjC,CAAsC,KAAtC,CAAb,EACH,OAAO,CAAC,CAAC,KAAK,CAAC,CAAD,CAAP,EAAY,CAAC,KAAK,CAAC,CAAD,CAAlB,EAAuB,CAAC,KAAK,CAAC,CAAD,CAA7B,EAAkC,CAAlC,CAAP,CADG,KAGA,MAAM,IAAI,KAAJ,CAAU,KAAK,GAAG,iCAAlB,CAAN;AACN;AAED,OAAM,SAAU,WAAV,CAAsB,KAAtB,EAAkC;AACtC,mBAAe,KAAK,CAAC,CAAD,CAApB,SAA2B,KAAK,CAAC,CAAD,CAAhC,SAAuC,KAAK,CAAC,CAAD,CAA5C,SAAmD,KAAK,CAAC,CAAD,CAAxD;AACD;AAED,OAAM,SAAU,gBAAV,CACJ,MADI,EAEJ,MAFI,EAGJ,QAHI,EAGY;AAEhB,SAAO,MAAM,CAAC,GAAP,CAAW,UAAC,CAAD,EAAI,CAAJ;AAAA,WAAU,CAAC,GAAG,CAAC,MAAM,CAAC,CAAD,CAAN,GAAY,CAAb,IAAkB,QAAhC;AAAA,GAAX,CAAP;AACD","sourcesContent":["export type Color = number[];\n\nexport function parseColor(color: string | Color): Color {\n  if (Array.isArray(color)) return color;\n  let cache;\n  const p = parseInt;\n  color = color.replace(/\\s/g, \"\"); // Remove all spaces\n\n  // Checks for 6 digit hex and converts string to integer\n  if ((cache = /#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color)))\n    return [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), 1];\n  // Checks for 3 digit hex and converts string to integer\n  else if ((cache = /#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color)))\n    return [\n      p(cache[1], 16) * 17,\n      p(cache[2], 16) * 17,\n      p(cache[3], 16) * 17,\n      1\n    ];\n  // Checks for rgba and converts string to\n  // integer/float using unary + operator to save bytes\n  else if (\n    (cache = /rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n  )\n    return [+cache[1], +cache[2], +cache[3], +cache[4]];\n  // Checks for rgb and converts string to\n  // integer/float using unary + operator to save bytes\n  else if ((cache = /rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color)))\n    return [+cache[1], +cache[2], +cache[3], 1];\n  // Otherwise throw an exception to make debugging easier\n  else throw new Error(color + \" is not supported by parseColor\");\n}\n\nexport function formatColor(color: Color): string {\n  return `rgba(${color[0]},${color[1]},${color[2]},${color[3]})`;\n}\n\nexport function interpolateColor(\n  color1: Color,\n  color2: Color,\n  position: number\n): Color {\n  return color1.map((c, i) => c + (color2[i] - c) * position);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}