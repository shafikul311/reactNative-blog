{"ast":null,"code":"export function parseColor(color) {\n  if (Array.isArray(color)) return color;\n  var cache;\n  var p = parseInt;\n  color = color.replace(/\\s/g, '');\n  if (cache = /#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color)) return [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), 1];else if (cache = /#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color)) return [p(cache[1], 16) * 17, p(cache[2], 16) * 17, p(cache[3], 16) * 17, 1];else if (cache = /rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color)) return [+cache[1], +cache[2], +cache[3], +cache[4]];else if (cache = /rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color)) return [+cache[1], +cache[2], +cache[3], 1];else throw new Error(color + ' is not supported by parseColor');\n}\nexport function formatColor(color) {\n  return \"rgba(\" + color[0] + \",\" + color[1] + \",\" + color[2] + \",\" + color[3] + \")\";\n}\nexport function interpolateColor(color1, color2, position) {\n  return color1.map(function (c, i) {\n    return c + (color2[i] - c) * position;\n  });\n}","map":{"version":3,"sources":["Color.ts"],"names":["Array","p","color","cache","color1","c","color2"],"mappings":"AAEA,OAAO,SAAA,UAAA,CAAA,KAAA,EAAkD;AACvD,MAAIA,KAAK,CAALA,OAAAA,CAAJ,KAAIA,CAAJ,EAA0B,OAAA,KAAA;AAC1B,MAAA,KAAA;AACA,MAAMC,CAAC,GAAP,QAAA;AACAC,EAAAA,KAAK,GAAGA,KAAK,CAALA,OAAAA,CAAAA,KAAAA,EAARA,EAAQA,CAARA;AAGA,MAAKC,KAAK,GAAG,iDAAA,IAAA,CAAb,KAAa,CAAb,EACE,OAAO,CAACF,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAAF,EAAE,CAAF,EAAkBF,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAAnB,EAAmB,CAAnB,EAAmCF,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAApC,EAAoC,CAApC,EADT,CACS,CAAP,CADF,KAGK,IAAKA,KAAK,GAAG,wCAAA,IAAA,CAAb,KAAa,CAAb,EACH,OAAO,CACLF,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAADF,EAAC,CAADA,GADK,EAAA,EAELA,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAADF,EAAC,CAADA,GAFK,EAAA,EAGLA,CAAC,CAACE,KAAK,CAAN,CAAM,CAAN,EAADF,EAAC,CAADA,GAHK,EAAA,EADJ,CACI,CAAP,CADG,KASA,IACFE,KAAK,GAAG,sDAAA,IAAA,CADN,KACM,CADN,EAGH,OAAO,CAAC,CAACA,KAAK,CAAP,CAAO,CAAP,EAAY,CAACA,KAAK,CAAlB,CAAkB,CAAlB,EAAuB,CAACA,KAAK,CAA7B,CAA6B,CAA7B,EAAkC,CAACA,KAAK,CAH5C,CAG4C,CAAxC,CAAP,CAHG,KAMA,IAAKA,KAAK,GAAG,iCAAA,IAAA,CAAb,KAAa,CAAb,EACH,OAAO,CAAC,CAACA,KAAK,CAAP,CAAO,CAAP,EAAY,CAACA,KAAK,CAAlB,CAAkB,CAAlB,EAAuB,CAACA,KAAK,CAA7B,CAA6B,CAA7B,EADJ,CACI,CAAP,CADG,KAGA,MAAM,IAAA,KAAA,CAAUD,KAAK,GAArB,iCAAM,CAAN;AAGP;AAAA,OAAO,SAAA,WAAA,CAAA,KAAA,EAA2C;AAChD,SAAA,UAAeA,KAAK,CAApB,CAAoB,CAApB,GAAA,GAAA,GAA2BA,KAAK,CAAhC,CAAgC,CAAhC,GAAA,GAAA,GAAuCA,KAAK,CAA5C,CAA4C,CAA5C,GAAA,GAAA,GAAmDA,KAAK,CAAxD,CAAwD,CAAxD,GAAA,GAAA;AAGF;AAAA,OAAO,SAAA,gBAAA,CAAA,MAAA,EAAA,MAAA,EAAA,QAAA,EAIE;AACP,SAAOE,MAAM,CAANA,GAAAA,CAAW,UAAA,CAAA,EAAA,CAAA,EAAA;AAAA,WAAUC,CAAC,GAAG,CAACC,MAAM,CAANA,CAAM,CAANA,GAAD,CAAA,IAAd,QAAA;AAAlB,GAAOF,CAAP;AACD","sourcesContent":["export type Color = number[];\n\nexport function parseColor(color: string | Color): Color {\n  if (Array.isArray(color)) return color;\n  let cache;\n  const p = parseInt;\n  color = color.replace(/\\s/g, ''); // Remove all spaces\n\n  // Checks for 6 digit hex and converts string to integer\n  if ((cache = /#([\\da-fA-F]{2})([\\da-fA-F]{2})([\\da-fA-F]{2})/.exec(color)))\n    return [p(cache[1], 16), p(cache[2], 16), p(cache[3], 16), 1];\n  // Checks for 3 digit hex and converts string to integer\n  else if ((cache = /#([\\da-fA-F])([\\da-fA-F])([\\da-fA-F])/.exec(color)))\n    return [\n      p(cache[1], 16) * 17,\n      p(cache[2], 16) * 17,\n      p(cache[3], 16) * 17,\n      1,\n    ];\n  // Checks for rgba and converts string to\n  // integer/float using unary + operator to save bytes\n  else if (\n    (cache = /rgba\\(([\\d]+),([\\d]+),([\\d]+),([\\d]+|[\\d]*.[\\d]+)\\)/.exec(color))\n  )\n    return [+cache[1], +cache[2], +cache[3], +cache[4]];\n  // Checks for rgb and converts string to\n  // integer/float using unary + operator to save bytes\n  else if ((cache = /rgb\\(([\\d]+),([\\d]+),([\\d]+)\\)/.exec(color)))\n    return [+cache[1], +cache[2], +cache[3], 1];\n  // Otherwise throw an exception to make debugging easier\n  else throw new Error(color + ' is not supported by parseColor');\n}\n\nexport function formatColor(color: Color): string {\n  return `rgba(${color[0]},${color[1]},${color[2]},${color[3]})`;\n}\n\nexport function interpolateColor(\n  color1: Color,\n  color2: Color,\n  position: number\n): Color {\n  return color1.map((c, i) => c + (color2[i] - c) * position);\n}\n"]},"metadata":{},"sourceType":"module"}